  //: Playground - noun: a place where people can play

import UIKit


// 詳解Swift改訂版 Chapter14ジェネリクス p330-p349

// 【14.1】ジェネリクスの概要

// ■ ジェネリクスとは

// ジェネリクス(generics) : 型をパラメータとしてプログラムを記述するための機能

// C++でテンプレートと呼ぶ機能も典型的なジェネリクス

// ジェネリクスの機能を利用してプログラムを作成することを、
// ジェネリックプログラミング（generic programming）と呼ぶ
// ジェネリクスの機能を使って定義された関数を
// ジェネリック関数、総称関数、あるいは汎用関数と呼ぶ


// ■ ジェネリクス関数の例

// Swiftの標準ライブラリで提供されているswap関数
// public func swap<T>(inout a: T, inout _ b: T)

var num1 = 10
var num2 = 20

swap(&num1, &num2)

num1
num2

// 関数swapは、任意の型Tについて、T型のinout引数を2つとり、値を返さない

// <T> : 型パラメータ(type parameter)

// 実際にプログラム内に記述された時に与えられた具体的な値の型をTに当てはめて推論し、
// 矛盾がなければコンパイルできる。
// この例では、2つの引数の型は同じでなければならない

// パラメータTは推論した型を当てはめ、
// 同じ型が他のどの箇所に現れるかを指定するための仕組みということができる
// プレースホルダ（placeholder）という用語を使って説明されることがある

max(10, 20)

// public func max<T : Comparable>(x: T, _ y: T, _ z: T, _ rest: T...) -> T

// public func max<T : Comparable>(x: T, _ y: T) -> T

// <T : Comparable> : 型TはプロトコルComparableに適合していなければならないという制約

// Comparable : 大小比較（<,>）、等しい・等しくない（==,!=）

// 型T自体が持つ比較の機能を使って、引数の中から最大値を取り出して返す。

// 2種類以上のパラメータを使うこともある。その場合には<T,U>のようにカンマで区切って記述する。

// 型パラメータとしてTを多用するのは、Swiftに限らず他の言語でも同様。
// 別の識別子でも良いが、Tと書いてあれば型パラメータである（ことが多い）という暗黙のルールがある。

// ■ ジェネリックな型の例

// 配列 [T]
// 辞書 [KeyType : ValueType]
// これらはプログラムを読み書きしやすくするために用意された記述法。

// パラメータ付き型指定を使うと
// 配列 Array<T>
// 辞書 Dictionary<KeyType, ValueType>

// ■ ジェネリクスとプロトコル

// 型パラメータが表す型に対して、
// 実際にはどのような演算や操作が適用できるのかが分かっていなければ
// 定義ができないことがある。

// 例えば
// 配列に格納できるデータ型には特に制約なし。
// 辞書の場合には等しいか違うかが判定できる型でなければキーとして使えない。
// max関数の例では、大小比較ができるデータ型でなければ最大値が得られない。

// このような型パラメータに対する条件はプロトコルとして定義しておく。

// 何らかの操作や演算ができるかどうかは、
// クラスやプロトコルの継承で知ることもできる。
// ジェネリクスの型パラメータではなく、
// クラスやプロトコルを型として使うプログラミングではいけないのか？

class Food {}
class カレー: Food {}
class 牛丼: Food {}

do {
    
    func レンジでチン(a: Food) -> Food {
        return a
    }
    
    var dinner = カレー() // 🍛
//    var lunch: カレー = レンジでチン(dinner) // 😱

    // サブクラスのインスタンスはスーパークラスのインスタンスとして振る舞うことができるので、
    // Food型の一種であるカレー型を関数「レンジでチン」の引数として渡すことは問題ない。

    // しかし、関数「レンジでチン」はFood型のインスタンスを返すことになっている。
    // スーパークラスのインスタンスはサブクラスのインスタンスとしては振る舞うことができないため、
    // カレー型の変数lunchにはFood型の返り値を代入できない。
    // 上の「レンジでチン」の定義では、「カレー」が引数の時に「牛丼」を返しても良いから。
}

// ジェネリック関数の定義ならば以下のようになる。

do {
    func レンジでチン<T: Food>(a: T) -> T {
        return a
    }

    // この定義では、引数の型と返り値の型は同じで、
    // クラスFoodまたはそのサブクラスでなければならない。
    // 引数がカレー型なら、返り値もカレー型であると推論するので、
    // 結果をカレー型の引数に代入することができる。

    var dinner = カレー() // 🍛
    var lunch: カレー = レンジでチン(dinner) // 😊
}

// ジェネリクスを利用すると、
// 継承の機能だけでは表現が難しい相互の関連性も記述できる場合があります。

// クラスやプロトコルを使ったプログラミングとジェネリクスは、
// どちらかだけがあればよいのではなく、うまく組み合わせて利用することが重要。


