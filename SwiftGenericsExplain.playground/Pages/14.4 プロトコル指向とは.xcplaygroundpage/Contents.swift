//: [Previous](@previous)

import Foundation


//: [Next](@next)

// 【14.4】プロトコル指向とは

// ■ クラスに基づくプログラミングの問題点

// クラスの良い点
// ・カプセル化
// ・アクセス制御
// ・抽象化
// ・名前空間
// ・表現能力の高い記法
// ・拡張性

// これらはすべて構造体と列挙型で実現できる。

// クラスの良くない点
// ・暗黙のうちにインスタンスが共有されることによってプログラムが複雑化する
// ・クラス継承は実装、特に格納型のプロパティを引き継ぐことになるため、
//   スーパークラスとサブクラスの間で値の初期化、
//   機能の継承や上書きなどに関する調整が必要になる。
// ・複数のサブクラスを作成しても、それらを関連付ける方法が存在しない

// ■ プロトコル指向の概要

// プロトコル指向
// クラス継承の代わりにプロトコルとジェネリクスの機能を利用してプログラムを構築する

// ・インスタンスの共有を避けるために参照型ではなく、値型のデータを使用する。
// ・プロトコルを利用して機能の共有を実現する。
//   データ型間の継承を利用しないとすれば、
//   値の初期化や機能の上書きなどに労力をかける必要はない。
// ・各データ型に適切な処理が適用されるように、
//   ジェネリクス機能を利用してプログラムの実装を行う。
//   各データがどのプロトコルに適合しているかという情報を利用して、
//   ジェネリクス関数や拡張定義の利用、あるいは制約を実現できる。
// ・特に、すでに存在している無関係なデータ型同士であっても、
//   拡張定義を利用すると、後から共通のプロトコルに適合していることにできてしまう。
//   これを遡及的モデリング（retroactive modeling）と呼ぶ。

// ■ オブジェクト指向とプロトコル指向

// オブジェクト指向
// ・当初は手続き型言語からのコペルニクス的転換、
//   あるいはパラダイムシフトであるなどともいわれた。
// ・概念を整理し、対象をモデル化する上で非常に分かりやすい考え方。

// すべての面において完璧ということはなく、
// 長年にわたって議論されてきたポイントがいくつかある。
// ・多重継承の問題
// ・あるクラスのサブクラスであるという制約だけではインタフェースの情報として不十分
//   （牛丼とカレーの話）

// プロトコル指向がオブジェクト指向に代わる方法論になるのか、あるいは補完する存在なのか？


// 引数の最後に関数が来る時は、呼び出し時、それを引数の位置に書かずに中にそのままかける
func calculate(a: Int, b: Int, function: (Int, Int) -> Int) -> Int {
    return function(a, b)
}
calculate(10, b: 20) {
    $0 * $1
}

// 引数が関数だけの時は、呼び出し時、関数のあとの（）を省略できる
func sayHello(greeting:(String) -> String) -> () {
    print(greeting("Hello"))
}
sayHello { $0 + ", World" } // Hello, World
sayHello { "Hi, " + $0 }    // Hi, Hello

















